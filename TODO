P R O C E D U R A L    C R E A T I O N    O F    A S T E R O I D S

	vertices concentric to the origin (0,0) and all within a specified range of the center: minRadius < radius < maxRadius
	angle between vertices is: minAngle < angle < maxAngle

	triangulate the polygon and add to the table of asteroids

	all asteroid creation will take place in a seperate thread and only as needed to avoid dropping the frame rate of the main game loop

	asteroids will be created outside the playable space but will be given a velocity depending on the side they are created on to bring them into playable

	large asteroids when shot will be split into 2 smaller asteroids
		- consider using an algorithm to divide the larger asteroid by it's vertices
			- the split will just be a list of vertices along which to divide the asteroid the first will be the one nearest the collision and then either
			the center or, using a ray derivitive of the projectile's velocity, generate a new vertex along the ray with some deviation and about midway between the intial vertex
			and the final vertex which is the vertex nearest the collision of the ray on the far side of the asteroid, the second collision on the polygon as the ray exits
			- or just create two smaller asteroids of abritary shapes

E F F I C I E N T    A S T E R O I D    D E S T R U C T I O N    A N D    C R E A T I O N

	- avoid using table.remove()S as it is a costly method
	- instead have two tables one with all the asteroid objects and the other with a list of dead asteroids
	- when an asteroid is destroyed mark it as dead and available for the next time we need to create an asteroid
	- 

T H E    P O W E R    O F    M E S H E S

	- use the power of meshes to render all eight copies of each object...
	- create all copies of objects in one mesh to render all at once as a list of triangles

LOL JK THE MESH IDEA DOESN'T WORK... THE ENTIRE MESH IS DRAWN ROTATED

T H E    P O W E R    O F    S H A D E R S

        - shaders though?? :wink:wink:
        - here's the basic idea, create a canvas, off render target, where you'll draw all the game objects to
        - now we're only going to draw a portion of the canvas to the screen as the entire playable area with a pre generated quad
        - the reason is that now we can use a custom pixel shader to wrap all graphics when the renderer attempts to draw something outside of the quad we are using for the world view
        - this way we will have a section of the canvas all the way around that which upon drawing to will automatically drawn to the opposite side of the screen offset by position
        - naturally to ensure we can see all game objects at any given time we will wrap all objects positions according to the dimensions of the world view quad
        - this solves the issue of having objects abruptly teleport to the other side of the screen when out of bounds
        - the pixel shader will ensure that as the object passes out of bounds it's graphics are smoothly wrapped to the other side of the screen
        - the other advantage is that now with a bit of work we can also define a set world size and just scale according to the user's display size to ensure a consistent experience across devices 
