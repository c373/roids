P R O C E D U R A L    C R E A T I O N    O F    A S T E R O I D S

	vertices concentric to the origin (0,0) and all within a specified range of the center: minRadius < radius < maxRadius
	angle between vertices is: minAngle < angle < maxAngle

	triangulate the polygon and add to the table of asteroids

	all asteroid creation will take place in a seperate thread and only as needed to avoid dropping the frame rate of the main game loop

	asteroids will be created outside the playable space but will be given a velocity depending on the side they are created on to bring them into playable

	large asteroids when shot will be split into 2 smaller asteroids
		- consider using an algorithm to divide the larger asteroid by it's vertices
			- the split will just be a list of vertices along which to divide the asteroid the first will be the one nearest the collision and then either
			the center or, using a ray derivitive of the projectile's velocity, generate a new vertex along the ray with some deviation and about midway between the intial vertex
			and the final vertex which is the vertex nearest the collision of the ray on the far side of the asteroid, the second collision on the polygon as the ray exits
			- or just create two smaller asteroids of abritary shapes


E F F I C I E N T    A S T E R O I D    D E S T R U C T I O N    A N D    C R E A T I O N

	- avoid using table.remove()S as it is a costly method
	- instead have two tables one with all the asteroid objects and the other with a list of dead asteroids
	- when an asteroid is destroyed mark it as dead and available for the next time we need to create an asteroid


T H E    P O W E R    O F    M E S H E S

	- use the power of meshes to render all eight copies of each object...
	- create all copies of objects in one mesh to render all at once as a list of triangles

LOL JK THE MESH IDEA DOESN'T WORK... ALL TRIANGLES ARE DRAWN ROTATED AROUND THE MESH'S MAIN ORIGIN


T H E    P O W E R    O F    S H A D E R S

		- shaders though?? :wink:wink:
		- here's the basic idea, create a canvas, off render target, where you'll draw all the game objects to
		- now we're only going to draw a portion of the canvas to the screen as the entire playable area with a pre generated quad
		- the reason is that now we can use a custom pixel shader to wrap all graphics when the renderer attempts to draw something outside of the quad we are using for the world view
		- this way we will have a section of the canvas all the way around that which upon drawing to will automatically draw to the opposite side of the screen offset by position
		- naturally to ensure we can see all game objects at any given time we will wrap all objects positions according to the dimensions of the world view quad
		- this solves the issue of having objects abruptly teleport to the other side of the screen when out of bounds
		- the pixel shader will ensure that as the object passes out of bounds it's graphics are smoothly wrapped to the other side of the screen
		- the other advantage is that now with a bit of work we can also define a set world size and just scale according to the user's display size to ensure a consistent experience across devices

LOL SO THE FRAGMENT SHADER THING DIDN'T WORK EITHER (FRAG SHADERS CAN'T CHANGE THE POSITION OF A PIXEL...)


T H E    P O W E R    O F    O F F - R E N D E R    T A R G E T S    ( F R A M E    B U F F E R S )

	- this one works lol (implemented and confirmed)
	- total # of draw calls = nObjects + 8 canvas wrapzone calls    VS    nObjects * 8 for each of the wrap cases
	- we draw all objects to a canvas, buffer, that is larger than the actual playable area by a constant offset on all sides
	- once all objects are drawn we split up the buffer zone into 8 individual sections that will be drawn in their diametrically opposed position overlapping the main playable area

	-----------------------
	| TL |    TOP    | TR |		topLeft > bottomRight
	-----------------------		top > bottom
	|    |           |    |		topRight > bottomLeft
	| L  |           | R  |		left > right
	|    |           |    |		right > left
	-----------------------		bottomLeft > topRight
	| BL |   BOTTOM  | BR |		bottom > top
	-----------------------		bottomRight > topLeft

	- after the main buffer and all overlapping wrap zones to the final buffer we draw this final buffer to the screen
	- general positioning and scaling can now be done on the final buffer as needed
	- using this method of wrapping the graphics along with a method to wrap objects positions within the intial buffer according to the world size we obtain sweet sweet smooth wrap transitions
	- NOTE: the buffer zone offset must be larger than the largest object in play to avoid clipping ( when the object crosses the edge of the initial main canvas before being positionally wrapped ) 


C O L L I S I O N    D E T E C T I O N    O N    W R A P S

	WHAT: an idea to detect and resolve collisions of asteroids on the portion of the asteroid that is wrapped around to the other side of the screen
	WHY IT'S NEEDED: asteroid's collision bodies aren't wrapped smoothly like the graphics... the collision body is wraped abrutly once the center (position of the asteroid) goes out of bounds
	HOW:
		- each asteroid will need a size assigned to it that is just the length of the vertex furthest from the center of the asteroid
		- we will use this value to determine when we need to do the more complex collision detection of asteroids
		- when the distance of the asteroids position to any one of the bound edges is less than or equal to this size value then we need to perform additional collision detection with modified position values for all the asteroid's vertices
		- we can modify the collision detection algorithm to take 4 additional values, the distances from each of the edges (top, bottom, left, right) when these fall below the size of the asteroid being tested, we will pass -1 when they don't to avoid unnecessary collision checks
		- this way each asteroid will have it's main collision detection based on it's real position and up to 3 additional collision checks with vertices offset to correspond to the graphical representation of the asteroid when it's wrapped on to the other edges of the screen


